<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tests/test_animators.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/test_animators.py" />
              <option name="originalContent" value="import unittest&#10;from unittest.mock import patch&#10;&#10;from graphMaker.Graph import BasicDirectedGraph, WeightedGraph, AGraph, BestFirstGraph&#10;from graphMaker.Animators.BreadthFirstGraphAnimator import BreadthFirstGraphAnimator&#10;from graphMaker.Animators.DepthFirstGraphAnimator import DepthFirstGraphAnimator&#10;from graphMaker.Animators.DijkstraGraphAnimator import DijkstraGraphAnimator&#10;from graphMaker.Animators.AStarGraphAnimator import AStarGraphAnimator&#10;from graphMaker.Animators.BestFirstGraphAnimator import BestFirstGraphAnimator&#10;from graphMaker.Animators.OptimalGraphAnimator import OptimalGraphAnimator&#10;from graphMaker.ENodeStateColors import ENodeStateColors&#10;&#10;&#10;class AnimatorTestMixin:&#10;    def patch_renderer(self):&#10;        # Patch GraphAnimator.create_frame to avoid matplotlib/PIL work during tests&#10;        patcher = patch('graphMaker.GraphAnimator.GraphAnimator.GraphAnimator.create_frame', autospec=True)&#10;        mocked = patcher.start()&#10;        # Register cleanup only if self has addCleanup (i.e., is a TestCase instance)&#10;        if hasattr(self, 'addCleanup'):&#10;            self.addCleanup(patcher.stop)&#10;        mocked.side_effect = lambda self_ref, filename, highlight_line=None, memory_state=None: self_ref.frames.append(&#10;            filename or f&quot;frame_{self_ref.frame_id:04d}.png&quot;&#10;        )&#10;&#10;&#10;class TestBreadthFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_bfs_reaches_goal_and_closes_some_nodes(self):&#10;        g = BasicDirectedGraph()&#10;        animator = BreadthFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;&#10;        # Goal should be marked as GOAL&#10;        self.assertEqual(animator.node_states[g.get_goal_node()], ENodeStateColors.GOAL)&#10;        # Start should be processed and placed into closed set&#10;        self.assertIn(g.get_start_node(), animator.closed_set)&#10;        # Some path node should also be closed (F is on all paths to T)&#10;        self.assertIn('F', animator.closed_set)&#10;&#10;&#10;class TestDepthFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_dfs_marks_closed_or_goal(self):&#10;        g = BasicDirectedGraph()&#10;        animator = DepthFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        # At least one node should be CLOSED or GOAL&#10;        any_closed_or_goal = any(state in (ENodeStateColors.CLOSED, ENodeStateColors.GOAL) for state in animator.node_states.values())&#10;        self.assertTrue(any_closed_or_goal)&#10;&#10;&#10;class TestDijkstraAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_dijkstra_finds_finite_distance_to_goal(self):&#10;        g = WeightedGraph()&#10;        animator = DijkstraGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertLess(animator.distances[g.get_goal_node()], float('inf'))&#10;        self.assertGreaterEqual(len(animator.closed_set), 1)&#10;&#10;&#10;class TestAStarAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_astar_reaches_goal(self):&#10;        g = AGraph()&#10;        animator = AStarGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertEqual(animator.node_states[g.get_goal_node()], ENodeStateColors.GOAL)&#10;&#10;&#10;class TestBestFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_best_first_visits_nodes(self):&#10;        g = BestFirstGraph()&#10;        animator = BestFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertGreaterEqual(len(animator.visited), 1)&#10;&#10;&#10;class TestOptimalAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_optimal_progresses_and_sets_closed(self):&#10;        g = WeightedGraph()&#10;        animator = OptimalGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertGreaterEqual(len(animator.visited), 1)&#10;        self.assertTrue(any(state == ENodeStateColors.CLOSED for state in animator.node_states.values()))&#10;&#10;&#10;if __name__ == '__main__':&#10;    unittest.main()" />
              <option name="updatedContent" value="import unittest&#10;from unittest.mock import patch&#10;&#10;from graphMaker.Graph import BasicDirectedGraph, WeightedGraph, AGraph, BestFirstGraph&#10;from graphMaker.Animators.BreadthFirstGraphAnimator import BreadthFirstGraphAnimator&#10;from graphMaker.Animators.DepthFirstGraphAnimator import DepthFirstGraphAnimator&#10;from graphMaker.Animators.DijkstraGraphAnimator import DijkstraGraphAnimator&#10;from graphMaker.Animators.AStarGraphAnimator import AStarGraphAnimator&#10;from graphMaker.Animators.BestFirstGraphAnimator import BestFirstGraphAnimator&#10;from graphMaker.Animators.OptimalGraphAnimator import OptimalGraphAnimator&#10;from graphMaker.ENodeStateColors import ENodeStateColors&#10;&#10;&#10;class AnimatorTestMixin:&#10;    def patch_renderer(self):&#10;        # Patch GraphAnimator.create_frame to avoid matplotlib/PIL work during tests&#10;        patcher = patch('graphMaker.GraphAnimator.GraphAnimator.GraphAnimator.create_frame', autospec=True)&#10;        mocked = patcher.start()&#10;        # Register cleanup only if self has addCleanup (i.e., is a TestCase instance)&#10;        if hasattr(self, 'addCleanup'):&#10;            self.addCleanup(patcher.stop)&#10;        mocked.side_effect = lambda self_ref, filename, highlight_line=None, memory_state=None: self_ref.frames.append(&#10;            filename or f&quot;frame_{self_ref.frame_id:04d}.png&quot;&#10;        )&#10;&#10;&#10;class TestBreadthFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_bfs_reaches_goal_and_closes_some_nodes(self):&#10;        g = BasicDirectedGraph()&#10;        animator = BreadthFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;&#10;        # Goal should be marked as GOAL&#10;        self.assertEqual(animator.node_states[g.get_goal_node()], ENodeStateColors.GOAL)&#10;        # Start should be processed and placed into closed set&#10;        self.assertIn(g.get_start_node(), animator.closed_set)&#10;        # Some path node should also be closed (F is on all paths to T)&#10;        self.assertIn('F', animator.closed_set)&#10;&#10;&#10;class TestDepthFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_dfs_marks_closed_or_goal(self):&#10;        g = BasicDirectedGraph()&#10;        animator = DepthFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        # At least one node should be CLOSED or GOAL&#10;        any_closed_or_goal = any(state in (ENodeStateColors.CLOSED, ENodeStateColors.GOAL) for state in animator.node_states.values())&#10;        self.assertTrue(any_closed_or_goal)&#10;&#10;&#10;class TestDijkstraAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_dijkstra_finds_finite_distance_to_goal(self):&#10;        g = WeightedGraph()&#10;        animator = DijkstraGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertLess(animator.distances[g.get_goal_node()], float('inf'))&#10;        self.assertGreaterEqual(len(animator.closed_set), 1)&#10;&#10;&#10;class TestAStarAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_astar_reaches_goal(self):&#10;        g = AGraph()&#10;        animator = AStarGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertEqual(animator.node_states[g.get_goal_node()], ENodeStateColors.GOAL)&#10;&#10;&#10;class TestBestFirstAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_best_first_visits_nodes(self):&#10;        g = BestFirstGraph()&#10;        animator = BestFirstGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertGreaterEqual(len(animator.visited), 1)&#10;&#10;&#10;class TestOptimalAnimator(unittest.TestCase, AnimatorTestMixin):&#10;    def setUp(self):&#10;        self.patch_renderer()&#10;&#10;    def test_optimal_progresses_and_sets_closed(self):&#10;        g = WeightedGraph()&#10;        animator = OptimalGraphAnimator(g, g.get_start_node(), g.get_goal_node(), g.get_children())&#10;        animator.generate_animation()&#10;        self.assertGreaterEqual(len(animator.visited), 1)&#10;        self.assertTrue(any(state == ENodeStateColors.CLOSED for state in animator.node_states.values()))&#10;&#10;&#10;if __name__ == '__main__':&#10;    unittest.main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>